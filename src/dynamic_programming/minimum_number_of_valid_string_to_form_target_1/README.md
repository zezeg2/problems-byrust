# 유효한 문자열로 Target 만들기

`words` 배열에 있는 단어들의 접두사(prefix)들을 이용하여 `target` 문자열을 만드는 문제입니다. 이때 사용되는 접두사들의 최소 개수를 찾는 것이 목표입니다. 만약 `target`을 만들 수 없다면 -1을 반환합니다.

![3291 Minimum Number of Valid Strings to Form Target I.png](../../../images/3291%20Minimum%20Number%20of%20Valid%20Strings%20to%20Form%20Target%20I.png)

## 알고리즘

이 문제는 동적 프로그래밍(Dynamic Programming)과 트라이(Trie) 자료구조를 함께 사용하여 효율적으로 해결할 수 있습니다.

### 1. 트라이 (Trie)

- **목적**: `words`에 포함된 모든 단어를 트라이에 저장하여, `target`의 부분 문자열이 이 단어들의 접두사인지 O(L) 시간 복잡도(L은 문자열 길이)로 빠르게 확인할 수 있습니다.
- **특징**: `words`의 단어들을 **정방향**으로 트라이에 삽입합니다. 이는 DP 상태 전이 과정에서 `target` 문자열을 앞에서부터 탐색하며 유효한 부분 문자열(접두사)을 찾아내기 위함입니다.

### 2. 동적 프로그래밍 (Dynamic Programming)

- **상태 정의**:
  `dp[i]` = `target` 문자열의 첫 `i`개 문자(`target[0..i]`)를 만드는 데 필요한 유효한 문자열(접두사)의 최소 개수.

- **기저 상태**:
  `dp[0] = 0` (빈 문자열을 만드는 데에는 0개의 문자열이 필요합니다.)

- **상태 전이**:
  `dp` 배열을 순회하며 `dp[i]`를 계산합니다. `dp[i]`는 `target[0..i]`까지 만드는 최소 비용을 의미합니다.

  `i`를 0부터 `n-1`(target의 길이 - 1)까지 순회하며 다음을 반복합니다:
  1. 만약 `dp[i]`가 유효한 값(즉, `target[0..i]`를 만들 수 있는 방법이 존재함)이라면, `target[i]`에서 시작하는 새로운 조각을 만들 수 있습니다.
  2. `target[i]`부터 시작하여 트라이를 탐색합니다. `j`를 `i`부터 `n-1`까지 순회하며 `target[i..=j]`가 유효한 접두사인지 확인합니다.
  3. 트라이 탐색을 통해 `target[i..=j]`가 유효한 접두사임이 확인되면, `dp[j+1]`을 갱신할 수 있습니다.
     ```
     dp[j + 1] = min(dp[j + 1], dp[i] + 1)
     ```
     이는 `target[0..i]`를 만드는 최소 비용(`dp[i]`)에 `target[i..=j]`라는 새로운 조각 하나를 추가하는 것을 의미합니다.
  4. 만약 트라이 경로가 끊기면, 더 이상 `target[i]`에서 시작하는 유효한 접두사가 없으므로 내부 반복을 중단합니다.

- **최종 결과**:
  모든 계산이 끝난 후 `dp[n]` 값이 최종 결과가 됩니다. 만약 `dp[n]`이 초기값(무한대) 그대로라면 `target`을 만들 수 없는 경우이므로 -1을 반환합니다.