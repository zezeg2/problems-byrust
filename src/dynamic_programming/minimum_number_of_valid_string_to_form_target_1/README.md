# 3291. Minimum Number of Valid Strings to Form Target I
![3291 Minimum Number of Valid Strings to Form Target I.png](../../../images/3291%20Minimum%20Number%20of%20Valid%20Strings%20to%20Form%20Target%20I.png)
`words` 배열에 있는 단어들의 접두사(prefix)들을 이용하여 `target` 문자열을 만드는 문제입니다. 이때 사용되는 접두사들의 최소 개수를 찾는 것이 목표입니다. 만약 `target`을 만들 수 없다면 -1을 반환합니다.

## 알고리즘

이 문제는 동적 프로그래밍(Dynamic Programming)을 사용하여 해결할 수 있습니다. `target` 문자열의 부분 문자열이 `words`에 있는 단어의 접두사인지 효율적으로 확인하기 위해 트라이(Trie) 자료구조를 함께 사용합니다.

### 1. 트라이 (Trie)

- **목적**: `words`에 포함된 모든 단어를 트라이에 저장하여, 특정 문자열이 이 단어들의 접두사인지 O(L) 시간 복잡도(L은 문자열 길이)로 빠르게 확인합니다.
- **특징**: 이 문제의 풀이에서는 `words`의 단어들을 **역순으로** 트라이에 삽입합니다. 이는 DP 상태 전이 과정에서 `target` 문자열을 뒤에서부터 탐색하며 유효한 부분 문자열(접두사)을 효율적으로 찾기 위함입니다.

### 2. 동적 프로그래밍 (Dynamic Programming)

- **상태 정의**:
  `dp[i]` = `target` 문자열의 첫 `i`개 문자(`target[0..i]`)를 만드는 데 필요한 유효한 문자열(접두사)의 최소 개수.

- **기저 상태**:
  `dp[0] = 0` (빈 문자열을 만드는 데에는 0개의 문자열이 필요합니다.)

- **상태 전이**:
  `dp[i]`를 계산하기 위해, `target` 문자열의 `i`번째 문자 앞에서 만들 수 있는 모든 유효한 마지막 조각을 고려합니다.

  `i`를 1부터 `n`(target의 길이)까지 순회하며 다음을 반복합니다:
  1. `j`를 `i-1`부터 `0`까지 역순으로 순회합니다. `target[j..i]`는 `target[0..i]`를 완성하는 마지막 조각 후보가 됩니다.
  2. `target[j..i]`가 `words`에 있는 단어의 접두사인지 확인합니다. 이 과정은 `target`의 `i-1` 인덱스부터 `j`까지 문자를 하나씩 따라가며 역순 트라이를 탐색하여 효율적으로 수행됩니다.
  3. 만약 `target[j..i]`가 유효한 접두사이고, `dp[j]`가 유효한 값(즉, `target[0..j]`를 만들 수 있는 방법이 존재함)이라면, `dp[i]`를 갱신할 수 있습니다.
     ```
     dp[i] = min(dp[i], dp[j] + 1)
     ```
     이는 `target[0..j]`를 만드는 최소 비용(`dp[j]`)에 마지막 조각 `target[j..i]` 하나를 추가하는 것을 의미합니다.

- **최종 결과**:
  모든 계산이 끝난 후 `dp[n]` 값이 최종 결과가 됩니다. 만약 `dp[n]`이 초기값(무한대) 그대로라면 `target`을 만들 수 없는 경우이므로 -1을 반환합니다.

